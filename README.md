# Java CRUD Rest API using Spring Boot, Hibernate, Postgres, Docker and Docker Compose

<h1>Introduction:</h1>
<ol>
I follow the next steps:
<li>Create a Java application using Spring Boot, Spring Web, Spring Data and Hibernate</li>
<li>Run the Postgres database in a container using Docker Compose, and test connection with TablePlus</li>
<li>Dockerize the Java application writing a Dockerfile and docker-compose.yml file to run the application and the database</li>
<li>Build the Java app, build the Docker image and run the container using Docker Compose, then test it with Postman</li>
</ol>

<h2> Concepts:</h2>
<p><strong>Microservices:</strong>
Is an architectural style that structures an application as a collection of sevices that are Indeppendent and Loosely Coupled.
It also supports polyglot  programming. Services don't need to share the same technology stack libraries or framework. The development team can select more suitable tech for the functional needs.

<h3>Features of Microservice</h3>
<li>Decoupled</li>
<li>Separate teams</li>
<li>Continuous delivery</li>
<li>Agility</li>
<li>Scalability</li>

</p>    


<p><strong>Docker:</strong>
<h3>Common commands:</h3>
  run         Create and run a new container from an image
  exec        Execute a command in a running container
  ps          List containers
  build       Build an image from a Dockerfile
  pull        Download an image from a registry
  push        Upload an image to a registry
  images      List images
  login       Log in to a registry
  logout      Log out from a registry
  search      Search Docker Hub for images
  version     Show the Docker version information
  info        Display system-wide information
</p>  
